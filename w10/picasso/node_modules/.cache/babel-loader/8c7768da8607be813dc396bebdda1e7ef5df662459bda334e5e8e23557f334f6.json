{"ast":null,"code":"import parse from 'date-fns/parse';\nimport isValid from 'date-fns/isValid';\nimport formatDate from 'date-fns/format';\nimport isWithinInterval from 'date-fns/isWithinInterval';\nimport isEqual from 'date-fns/isEqual';\nimport isBefore from 'date-fns/isBefore';\nimport isAfter from 'date-fns/isAfter';\nimport { utcToZonedTime, format as tzFormat, toDate } from 'date-fns-tz';\n// Convert date to given timezone. If timezone is undefined, return given date as is.\nexport const timezoneConvert = (date, timeZone) => {\n  const convert = dateToConvert => {\n    if (timeZone) {\n      /**\n       * Prevent invalid IANA timezone error. This is likely to happen\n       * when someone is editing properties in a Storybook examples.\n       */\n      try {\n        return utcToZonedTime(dateToConvert, timeZone);\n      } catch (_a) {\n        return dateToConvert;\n      }\n    }\n    return dateToConvert;\n  };\n  return Array.isArray(date) ? date.map(convert) : convert(date);\n};\n// Format date in given timezone. If timezone is undefined, return given date as is.\nexport const timezoneFormat = (date, timeZone) => {\n  if (timeZone) {\n    /**\n     * Prevent invalid IANA timezone error. This is likely to happen\n     * when someone is editing properties in a Storybook examples.\n     */\n    try {\n      /**\n       * Maintain the same date and time, but formatted in the given timezone\n       * so next time the user edits the date it's not recalculated.\n       */\n      return new Date(tzFormat(date, 'MMM dd yyyy HH:mm:ss OOOO', {\n        timeZone\n      }));\n    } catch (_a) {\n      return date;\n    }\n  }\n  return date;\n};\nexport const formatDateRange = (dates, format) => dates.map(date => formatDate(date, format)).join(' - ');\nexport const isDateValid = (date, pattern) => {\n  return date.length === pattern.length && isValid(parse(date, pattern, new Date()));\n};\nexport const isDateAfter = (date, dateToCompare) => isEqual(date, dateToCompare) || isAfter(date, dateToCompare);\nexport const isDateBefore = (date, dateToCompare) => isEqual(date, dateToCompare) || isBefore(date, dateToCompare);\n// eslint-disable-next-line complexity\nexport const isDateWithinInterval = (date, minDate, maxDate) => {\n  if (!minDate && !maxDate) {\n    return true;\n  }\n  if (minDate && maxDate) {\n    return isWithinInterval(date, {\n      start: minDate,\n      end: maxDate\n    });\n  }\n  if (minDate) {\n    return isDateAfter(date, minDate);\n  }\n  if (maxDate) {\n    return isDateBefore(date, maxDate);\n  }\n  return false;\n};\nexport const datePickerParseDateString = (value, _ref) => {\n  let {\n    customParser,\n    dateFormat,\n    timezone,\n    minDate,\n    maxDate\n  } = _ref;\n  if (!value) {\n    return;\n  }\n  const isValidDateString = isDateValid(value, dateFormat);\n  const parsedNextValue = customParser && !isValidDateString ? customParser(value, {\n    timezone\n  }) : parse(value, dateFormat, new Date());\n  if (!parsedNextValue || !isValid(parsedNextValue)) {\n    return;\n  }\n  const nextTimezoneValue = timezoneFormat(parsedNextValue, timezone);\n  if (!isDateWithinInterval(nextTimezoneValue, minDate, maxDate)) {\n    return;\n  }\n  return nextTimezoneValue;\n};\nexport const isValidDateValue = dateValue => typeof dateValue !== 'string';\nexport const getStartOfTheDayDate = date => {\n  if (!date) {\n    return date;\n  }\n  // to prevent mutation of the original date\n  const clonedDate = toDate(date);\n  clonedDate.setHours(0, 0, 0, 0);\n  return clonedDate;\n};","map":{"version":3,"names":["parse","isValid","formatDate","isWithinInterval","isEqual","isBefore","isAfter","utcToZonedTime","format","tzFormat","toDate","timezoneConvert","date","timeZone","convert","dateToConvert","_a","Array","isArray","map","timezoneFormat","Date","formatDateRange","dates","join","isDateValid","pattern","length","isDateAfter","dateToCompare","isDateBefore","isDateWithinInterval","minDate","maxDate","start","end","datePickerParseDateString","value","_ref","customParser","dateFormat","timezone","isValidDateString","parsedNextValue","nextTimezoneValue","isValidDateValue","dateValue","getStartOfTheDayDate","clonedDate","setHours"],"sources":["../../src/DatePicker/utils.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}