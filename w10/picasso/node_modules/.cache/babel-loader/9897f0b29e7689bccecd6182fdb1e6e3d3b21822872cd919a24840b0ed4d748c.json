{"ast":null,"code":"var diff = require('fast-diff');\nvar equal = require('deep-equal');\nvar extend = require('extend');\nvar op = require('./op');\nvar NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n\nvar Delta = function (ops) {\n  // Assume we are given a well formed ops\n  if (Array.isArray(ops)) {\n    this.ops = ops;\n  } else if (ops != null && Array.isArray(ops.ops)) {\n    this.ops = ops.ops;\n  } else {\n    this.ops = [];\n  }\n};\nDelta.prototype.insert = function (text, attributes) {\n  var newOp = {};\n  if (text.length === 0) return this;\n  newOp.insert = text;\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\nDelta.prototype['delete'] = function (length) {\n  if (length <= 0) return this;\n  return this.push({\n    'delete': length\n  });\n};\nDelta.prototype.retain = function (length, attributes) {\n  if (length <= 0) return this;\n  var newOp = {\n    retain: length\n  };\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\nDelta.prototype.push = function (newOp) {\n  var index = this.ops.length;\n  var lastOp = this.ops[index - 1];\n  newOp = extend(true, {}, newOp);\n  if (typeof lastOp === 'object') {\n    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {\n      this.ops[index - 1] = {\n        'delete': lastOp['delete'] + newOp['delete']\n      };\n      return this;\n    }\n    // Since it does not matter if we insert before or after deleting at the same index,\n    // always prefer to insert first\n    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {\n      index -= 1;\n      lastOp = this.ops[index - 1];\n      if (typeof lastOp !== 'object') {\n        this.ops.unshift(newOp);\n        return this;\n      }\n    }\n    if (equal(newOp.attributes, lastOp.attributes)) {\n      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {\n        this.ops[index - 1] = {\n          insert: lastOp.insert + newOp.insert\n        };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;\n        return this;\n      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {\n        this.ops[index - 1] = {\n          retain: lastOp.retain + newOp.retain\n        };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;\n        return this;\n      }\n    }\n  }\n  if (index === this.ops.length) {\n    this.ops.push(newOp);\n  } else {\n    this.ops.splice(index, 0, newOp);\n  }\n  return this;\n};\nDelta.prototype.chop = function () {\n  var lastOp = this.ops[this.ops.length - 1];\n  if (lastOp && lastOp.retain && !lastOp.attributes) {\n    this.ops.pop();\n  }\n  return this;\n};\nDelta.prototype.filter = function (predicate) {\n  return this.ops.filter(predicate);\n};\nDelta.prototype.forEach = function (predicate) {\n  this.ops.forEach(predicate);\n};\nDelta.prototype.map = function (predicate) {\n  return this.ops.map(predicate);\n};\nDelta.prototype.partition = function (predicate) {\n  var passed = [],\n    failed = [];\n  this.forEach(function (op) {\n    var target = predicate(op) ? passed : failed;\n    target.push(op);\n  });\n  return [passed, failed];\n};\nDelta.prototype.reduce = function (predicate, initial) {\n  return this.ops.reduce(predicate, initial);\n};\nDelta.prototype.changeLength = function () {\n  return this.reduce(function (length, elem) {\n    if (elem.insert) {\n      return length + op.length(elem);\n    } else if (elem.delete) {\n      return length - elem.delete;\n    }\n    return length;\n  }, 0);\n};\nDelta.prototype.length = function () {\n  return this.reduce(function (length, elem) {\n    return length + op.length(elem);\n  }, 0);\n};\nDelta.prototype.slice = function (start, end) {\n  start = start || 0;\n  if (typeof end !== 'number') end = Infinity;\n  var ops = [];\n  var iter = op.iterator(this.ops);\n  var index = 0;\n  while (index < end && iter.hasNext()) {\n    var nextOp;\n    if (index < start) {\n      nextOp = iter.next(start - index);\n    } else {\n      nextOp = iter.next(end - index);\n      ops.push(nextOp);\n    }\n    index += op.length(nextOp);\n  }\n  return new Delta(ops);\n};\nDelta.prototype.compose = function (other) {\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var ops = [];\n  var firstOther = otherIter.peek();\n  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {\n    var firstLeft = firstOther.retain;\n    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n      firstLeft -= thisIter.peekLength();\n      ops.push(thisIter.next());\n    }\n    if (firstOther.retain - firstLeft > 0) {\n      otherIter.next(firstOther.retain - firstLeft);\n    }\n  }\n  var delta = new Delta(ops);\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else if (thisIter.peekType() === 'delete') {\n      delta.push(thisIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (typeof otherOp.retain === 'number') {\n        var newOp = {};\n        if (typeof thisOp.retain === 'number') {\n          newOp.retain = length;\n        } else {\n          newOp.insert = thisOp.insert;\n        }\n        // Preserve null when composing with a retain, otherwise remove it for inserts\n        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n        if (attributes) newOp.attributes = attributes;\n        delta.push(newOp);\n\n        // Optimization if rest of other is just retain\n        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n          var rest = new Delta(thisIter.rest());\n          return delta.concat(rest).chop();\n        }\n\n        // Other op should be delete, we could be an insert or retain\n        // Insert + delete cancels out\n      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {\n        delta.push(otherOp);\n      }\n    }\n  }\n  return delta.chop();\n};\nDelta.prototype.concat = function (other) {\n  var delta = new Delta(this.ops.slice());\n  if (other.ops.length > 0) {\n    delta.push(other.ops[0]);\n    delta.ops = delta.ops.concat(other.ops.slice(1));\n  }\n  return delta;\n};\nDelta.prototype.diff = function (other, index) {\n  if (this.ops === other.ops) {\n    return new Delta();\n  }\n  var strings = [this, other].map(function (delta) {\n    return delta.map(function (op) {\n      if (op.insert != null) {\n        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n      }\n      var prep = delta === other ? 'on' : 'with';\n      throw new Error('diff() called ' + prep + ' non-document');\n    }).join('');\n  });\n  var delta = new Delta();\n  var diffResult = diff(strings[0], strings[1], index);\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  diffResult.forEach(function (component) {\n    var length = component[1].length;\n    while (length > 0) {\n      var opLength = 0;\n      switch (component[0]) {\n        case diff.INSERT:\n          opLength = Math.min(otherIter.peekLength(), length);\n          delta.push(otherIter.next(opLength));\n          break;\n        case diff.DELETE:\n          opLength = Math.min(length, thisIter.peekLength());\n          thisIter.next(opLength);\n          delta['delete'](opLength);\n          break;\n        case diff.EQUAL:\n          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n          var thisOp = thisIter.next(opLength);\n          var otherOp = otherIter.next(opLength);\n          if (equal(thisOp.insert, otherOp.insert)) {\n            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n          } else {\n            delta.push(otherOp)['delete'](opLength);\n          }\n          break;\n      }\n      length -= opLength;\n    }\n  });\n  return delta.chop();\n};\nDelta.prototype.eachLine = function (predicate, newline) {\n  newline = newline || '\\n';\n  var iter = op.iterator(this.ops);\n  var line = new Delta();\n  var i = 0;\n  while (iter.hasNext()) {\n    if (iter.peekType() !== 'insert') return;\n    var thisOp = iter.peek();\n    var start = op.length(thisOp) - iter.peekLength();\n    var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;\n    if (index < 0) {\n      line.push(iter.next());\n    } else if (index > 0) {\n      line.push(iter.next(index));\n    } else {\n      if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n        return;\n      }\n      i += 1;\n      line = new Delta();\n    }\n  }\n  if (line.length() > 0) {\n    predicate(line, {}, i);\n  }\n};\nDelta.prototype.transform = function (other, priority) {\n  priority = !!priority;\n  if (typeof other === 'number') {\n    return this.transformPosition(other, priority);\n  }\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var delta = new Delta();\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n      delta.retain(op.length(thisIter.next()));\n    } else if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (thisOp['delete']) {\n        // Our delete either makes their delete redundant or removes their retain\n        continue;\n      } else if (otherOp['delete']) {\n        delta.push(otherOp);\n      } else {\n        // We retain either their retain or insert\n        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n      }\n    }\n  }\n  return delta.chop();\n};\nDelta.prototype.transformPosition = function (index, priority) {\n  priority = !!priority;\n  var thisIter = op.iterator(this.ops);\n  var offset = 0;\n  while (thisIter.hasNext() && offset <= index) {\n    var length = thisIter.peekLength();\n    var nextType = thisIter.peekType();\n    thisIter.next();\n    if (nextType === 'delete') {\n      index -= Math.min(length, index - offset);\n      continue;\n    } else if (nextType === 'insert' && (offset < index || !priority)) {\n      index += length;\n    }\n    offset += length;\n  }\n  return index;\n};\nmodule.exports = Delta;","map":{"version":3,"names":["diff","require","equal","extend","op","NULL_CHARACTER","String","fromCharCode","Delta","ops","Array","isArray","prototype","insert","text","attributes","newOp","length","Object","keys","push","retain","index","lastOp","unshift","splice","chop","pop","filter","predicate","forEach","map","partition","passed","failed","target","reduce","initial","changeLength","elem","delete","slice","start","end","Infinity","iter","iterator","hasNext","nextOp","next","compose","other","thisIter","otherIter","firstOther","peek","firstLeft","peekType","peekLength","delta","Math","min","thisOp","otherOp","rest","concat","strings","prep","Error","join","diffResult","component","opLength","INSERT","DELETE","EQUAL","eachLine","newline","line","i","indexOf","transform","priority","transformPosition","offset","nextType","module","exports"],"sources":["/home/marcucosmin3/bootcamp/w10/picasso/node_modules/quill-delta/lib/delta.js"],"sourcesContent":["var diff = require('fast-diff');\nvar equal = require('deep-equal');\nvar extend = require('extend');\nvar op = require('./op');\n\n\nvar NULL_CHARACTER = String.fromCharCode(0);  // Placeholder char for embed in diff()\n\n\nvar Delta = function (ops) {\n  // Assume we are given a well formed ops\n  if (Array.isArray(ops)) {\n    this.ops = ops;\n  } else if (ops != null && Array.isArray(ops.ops)) {\n    this.ops = ops.ops;\n  } else {\n    this.ops = [];\n  }\n};\n\n\nDelta.prototype.insert = function (text, attributes) {\n  var newOp = {};\n  if (text.length === 0) return this;\n  newOp.insert = text;\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\n\nDelta.prototype['delete'] = function (length) {\n  if (length <= 0) return this;\n  return this.push({ 'delete': length });\n};\n\nDelta.prototype.retain = function (length, attributes) {\n  if (length <= 0) return this;\n  var newOp = { retain: length };\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\n\nDelta.prototype.push = function (newOp) {\n  var index = this.ops.length;\n  var lastOp = this.ops[index - 1];\n  newOp = extend(true, {}, newOp);\n  if (typeof lastOp === 'object') {\n    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {\n      this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };\n      return this;\n    }\n    // Since it does not matter if we insert before or after deleting at the same index,\n    // always prefer to insert first\n    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {\n      index -= 1;\n      lastOp = this.ops[index - 1];\n      if (typeof lastOp !== 'object') {\n        this.ops.unshift(newOp);\n        return this;\n      }\n    }\n    if (equal(newOp.attributes, lastOp.attributes)) {\n      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {\n        this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes\n        return this;\n      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {\n        this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes\n        return this;\n      }\n    }\n  }\n  if (index === this.ops.length) {\n    this.ops.push(newOp);\n  } else {\n    this.ops.splice(index, 0, newOp);\n  }\n  return this;\n};\n\nDelta.prototype.chop = function () {\n  var lastOp = this.ops[this.ops.length - 1];\n  if (lastOp && lastOp.retain && !lastOp.attributes) {\n    this.ops.pop();\n  }\n  return this;\n};\n\nDelta.prototype.filter = function (predicate) {\n  return this.ops.filter(predicate);\n};\n\nDelta.prototype.forEach = function (predicate) {\n  this.ops.forEach(predicate);\n};\n\nDelta.prototype.map = function (predicate) {\n  return this.ops.map(predicate);\n};\n\nDelta.prototype.partition = function (predicate) {\n  var passed = [], failed = [];\n  this.forEach(function(op) {\n    var target = predicate(op) ? passed : failed;\n    target.push(op);\n  });\n  return [passed, failed];\n};\n\nDelta.prototype.reduce = function (predicate, initial) {\n  return this.ops.reduce(predicate, initial);\n};\n\nDelta.prototype.changeLength = function () {\n  return this.reduce(function (length, elem) {\n    if (elem.insert) {\n      return length + op.length(elem);\n    } else if (elem.delete) {\n      return length - elem.delete;\n    }\n    return length;\n  }, 0);\n};\n\nDelta.prototype.length = function () {\n  return this.reduce(function (length, elem) {\n    return length + op.length(elem);\n  }, 0);\n};\n\nDelta.prototype.slice = function (start, end) {\n  start = start || 0;\n  if (typeof end !== 'number') end = Infinity;\n  var ops = [];\n  var iter = op.iterator(this.ops);\n  var index = 0;\n  while (index < end && iter.hasNext()) {\n    var nextOp;\n    if (index < start) {\n      nextOp = iter.next(start - index);\n    } else {\n      nextOp = iter.next(end - index);\n      ops.push(nextOp);\n    }\n    index += op.length(nextOp);\n  }\n  return new Delta(ops);\n};\n\n\nDelta.prototype.compose = function (other) {\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var ops = [];\n  var firstOther = otherIter.peek();\n  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {\n    var firstLeft = firstOther.retain;\n    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n      firstLeft -= thisIter.peekLength();\n      ops.push(thisIter.next());\n    }\n    if (firstOther.retain - firstLeft > 0) {\n      otherIter.next(firstOther.retain - firstLeft);\n    }\n  }\n  var delta = new Delta(ops);\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else if (thisIter.peekType() === 'delete') {\n      delta.push(thisIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (typeof otherOp.retain === 'number') {\n        var newOp = {};\n        if (typeof thisOp.retain === 'number') {\n          newOp.retain = length;\n        } else {\n          newOp.insert = thisOp.insert;\n        }\n        // Preserve null when composing with a retain, otherwise remove it for inserts\n        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n        if (attributes) newOp.attributes = attributes;\n        delta.push(newOp);\n\n        // Optimization if rest of other is just retain\n        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n          var rest = new Delta(thisIter.rest());\n          return delta.concat(rest).chop();\n        }\n\n      // Other op should be delete, we could be an insert or retain\n      // Insert + delete cancels out\n      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {\n        delta.push(otherOp);\n      }\n    }\n  }\n  return delta.chop();\n};\n\nDelta.prototype.concat = function (other) {\n  var delta = new Delta(this.ops.slice());\n  if (other.ops.length > 0) {\n    delta.push(other.ops[0]);\n    delta.ops = delta.ops.concat(other.ops.slice(1));\n  }\n  return delta;\n};\n\nDelta.prototype.diff = function (other, index) {\n  if (this.ops === other.ops) {\n    return new Delta();\n  }\n  var strings = [this, other].map(function (delta) {\n    return delta.map(function (op) {\n      if (op.insert != null) {\n        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n      }\n      var prep = (delta === other) ? 'on' : 'with';\n      throw new Error('diff() called ' + prep + ' non-document');\n    }).join('');\n  });\n  var delta = new Delta();\n  var diffResult = diff(strings[0], strings[1], index);\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  diffResult.forEach(function (component) {\n    var length = component[1].length;\n    while (length > 0) {\n      var opLength = 0;\n      switch (component[0]) {\n        case diff.INSERT:\n          opLength = Math.min(otherIter.peekLength(), length);\n          delta.push(otherIter.next(opLength));\n          break;\n        case diff.DELETE:\n          opLength = Math.min(length, thisIter.peekLength());\n          thisIter.next(opLength);\n          delta['delete'](opLength);\n          break;\n        case diff.EQUAL:\n          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n          var thisOp = thisIter.next(opLength);\n          var otherOp = otherIter.next(opLength);\n          if (equal(thisOp.insert, otherOp.insert)) {\n            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n          } else {\n            delta.push(otherOp)['delete'](opLength);\n          }\n          break;\n      }\n      length -= opLength;\n    }\n  });\n  return delta.chop();\n};\n\nDelta.prototype.eachLine = function (predicate, newline) {\n  newline = newline || '\\n';\n  var iter = op.iterator(this.ops);\n  var line = new Delta();\n  var i = 0;\n  while (iter.hasNext()) {\n    if (iter.peekType() !== 'insert') return;\n    var thisOp = iter.peek();\n    var start = op.length(thisOp) - iter.peekLength();\n    var index = typeof thisOp.insert === 'string' ?\n      thisOp.insert.indexOf(newline, start) - start : -1;\n    if (index < 0) {\n      line.push(iter.next());\n    } else if (index > 0) {\n      line.push(iter.next(index));\n    } else {\n      if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n        return;\n      }\n      i += 1;\n      line = new Delta();\n    }\n  }\n  if (line.length() > 0) {\n    predicate(line, {}, i);\n  }\n};\n\nDelta.prototype.transform = function (other, priority) {\n  priority = !!priority;\n  if (typeof other === 'number') {\n    return this.transformPosition(other, priority);\n  }\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var delta = new Delta();\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n      delta.retain(op.length(thisIter.next()));\n    } else if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (thisOp['delete']) {\n        // Our delete either makes their delete redundant or removes their retain\n        continue;\n      } else if (otherOp['delete']) {\n        delta.push(otherOp);\n      } else {\n        // We retain either their retain or insert\n        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n      }\n    }\n  }\n  return delta.chop();\n};\n\nDelta.prototype.transformPosition = function (index, priority) {\n  priority = !!priority;\n  var thisIter = op.iterator(this.ops);\n  var offset = 0;\n  while (thisIter.hasNext() && offset <= index) {\n    var length = thisIter.peekLength();\n    var nextType = thisIter.peekType();\n    thisIter.next();\n    if (nextType === 'delete') {\n      index -= Math.min(length, index - offset);\n      continue;\n    } else if (nextType === 'insert' && (offset < index || !priority)) {\n      index += length;\n    }\n    offset += length;\n  }\n  return index;\n};\n\n\nmodule.exports = Delta;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}