var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, Fragment, } from 'react';
import Autocomplete from '../Autocomplete';
import TagSelectorInput from '../TagSelectorInput';
import TagSelectorLabel from '../TagSelectorLabel';
import unsafeErrorLog from '../utils/unsafe-error-log';
import noop from '../utils/noop';
import { usePropDeprecationWarning } from '../utils/use-deprecation-warnings';
const EMPTY_INPUT_VALUE = '';
export const filterOutSelectedOptions = (options, values, getKey = (item) => item.value) => {
    if (!options) {
        return null;
    }
    const valuesKeySet = values.reduce((acc, item) => acc.add(getKey(item)), new Set());
    return options.filter(option => !valuesKeySet.has(getKey(option)));
};
const getItemText = (item) => (item && item.text) || EMPTY_INPUT_VALUE;
export const TagSelector = forwardRef(function TagSelector(props, ref) {
    const { disabled, enableAutofill, getDisplayValue = getItemText, getKey: customGetKey, inputValue = '', loading, noOptionsText, onBlur, onChange = noop, onFocus, onInputChange = noop, onOtherOptionSelect = noop, options = [], otherOptionLabel, placeholder, renderLabel: customRenderLabel, renderOption, showOtherOption, value: values = [], width, popperContainer, popperOptions, error, status, testIds } = props, rest = __rest(props, ["disabled", "enableAutofill", "getDisplayValue", "getKey", "inputValue", "loading", "noOptionsText", "onBlur", "onChange", "onFocus", "onInputChange", "onOtherOptionSelect", "options", "otherOptionLabel", "placeholder", "renderLabel", "renderOption", "showOtherOption", "value", "width", "popperContainer", "popperOptions", "error", "status", "testIds"]);
    usePropDeprecationWarning({
        props,
        name: 'error',
        componentName: 'TagSelector',
        description: 'Use the `status` prop instead. `error` is deprecated and will be removed in the next major release.',
    });
    const handleDelete = (value) => {
        if (disabled) {
            return;
        }
        const index = values.indexOf(value);
        onChange([...values.slice(0, index), ...values.slice(index + 1)]);
    };
    const handleKeyDown = (event, newInputValue) => {
        const hasSelection = values.length;
        const isDeleting = event.key === 'Backspace';
        if (hasSelection && !newInputValue && isDeleting) {
            handleDelete(values[values.length - 1]);
        }
    };
    const handleSelect = (autocompleteItem) => {
        const item = autocompleteItem;
        onChange([...values, item]);
        onInputChange('');
    };
    const handleOtherOptionSelect = (value) => {
        onInputChange('');
        onOtherOptionSelect(value);
    };
    const getKey = (item) => {
        if (customGetKey) {
            return customGetKey(item);
        }
        if (item.value !== undefined) {
            return item.value;
        }
        unsafeErrorLog('TagSelector expects you to provide key prop value with getKey or Item.value!');
        return '';
    };
    const autocompleteOptions = filterOutSelectedOptions(options, values, getKey);
    const renderLabel = (item) => {
        const displayValue = getDisplayValue(item);
        const handleItemDelete = () => handleDelete(item);
        if (customRenderLabel) {
            return customRenderLabel({
                disabled,
                item,
                displayValue,
                onDelete: handleItemDelete,
            });
        }
        return (React.createElement(TagSelectorLabel, { disabled: disabled, onDelete: handleItemDelete }, displayValue));
    };
    const renderTags = values.map(item => (React.createElement(Fragment, { key: getKey(item) }, renderLabel(item))));
    return (React.createElement(Autocomplete, Object.assign({}, rest, { status: error ? 'error' : status, ref: ref, placeholder: values.length === 0 ? placeholder : undefined, options: autocompleteOptions, value: inputValue, onSelect: handleSelect, onOtherOptionSelect: handleOtherOptionSelect, onChange: onInputChange, onKeyDown: handleKeyDown, onFocus: onFocus, onBlur: onBlur, startAdornment: renderTags, loading: loading, disabled: disabled, inputComponent: TagSelectorInput, width: width, showOtherOption: showOtherOption, otherOptionText: otherOptionLabel, noOptionsText: noOptionsText, enableAutofill: enableAutofill, getDisplayValue: getDisplayValue, renderOption: renderOption, enableReset: false, getKey: getKey, popperContainer: popperContainer, popperOptions: popperOptions, testIds: testIds })));
});
TagSelector.defaultProps = {
    enableAutofill: false,
    getDisplayValue: getItemText,
    loading: false,
    onChange: noop,
    closeOnSelect: true,
    onInputChange: noop,
    onOtherOptionSelect: noop,
    options: [],
    otherOptionLabel: 'Add new option: ',
    noOptionsText: 'No matches found',
    placeholder: '',
    showOtherOption: false,
    status: 'default',
};
TagSelector.displayName = 'TagSelector';
export default TagSelector;
//# sourceMappingURL=TagSelector.js.map