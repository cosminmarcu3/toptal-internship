var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { useTitleCase } from '@toptal/picasso-shared';
import cx from 'classnames';
import { makeStyles } from '@material-ui/core';
import Typography from '../Typography';
import Tooltip from '../Tooltip';
import Container from '../Container';
import Badge from '../Badge';
import TagRectangular from '../TagRectangular';
import { getReactNodeTextContent } from '../utils';
import styles from './styles';
import Indicator from '../Indicator';
import useIndicatorOnParentItem from './useIndicatorOnParentItem';
const useStyles = makeStyles(styles, {
    name: 'PicassoSidebarItemContent',
});
const resolveChildrenText = (text, titleCase) => typeof text === 'string' ? (React.createElement(Typography, { color: 'inherit', size: 'medium', titleCase: titleCase, noWrap: true }, text)) : (text);
const ItemContentBadge = (props) => {
    const { children, variant = 'red' } = props, rest = __rest(props, ["children", "variant"]);
    const isOverlay = React.Children.count(children) > 0;
    return (React.createElement(Badge, Object.assign({ variant: variant, size: isOverlay ? 'small' : 'large' }, rest), children));
};
const CompactItemContent = (props) => {
    const { icon, children, badge, isIndicatorVisible, menu } = props;
    const classes = useStyles();
    const hasBadge = badge != null;
    const hasSubItems = menu != null;
    const wrappedIcon = icon && hasBadge && !hasSubItems ? (React.createElement(ItemContentBadge, { content: badge.content, variant: badge.variant }, icon)) : (icon);
    return (React.createElement(Container, { className: classes.noWrap, inline: true, flex: true, alignItems: 'center', padded: 'small' },
        React.createElement(Tooltip, { compact: true, placement: 'right', content: getReactNodeTextContent(children) },
            React.createElement("div", { className: classes.iconWrapper },
                wrappedIcon,
                hasSubItems && isIndicatorVisible && (React.createElement(Container, { className: classes.compactIndicator },
                    React.createElement(Indicator, { color: 'red' })))))));
};
const ExpandedItemContent = (props) => {
    const { icon, badge, children, testIds, tag, isIndicatorVisible, menu, isSubMenu, } = props;
    const classes = useStyles();
    const hasIcon = icon != null && !isSubMenu;
    const hasBadge = badge != null;
    const hasTag = tag != null;
    const hasSubItems = menu != null;
    return (React.createElement(Container, { className: classes.noWrap, inline: true, flex: true, alignItems: 'center', gap: 'xsmall' },
        !isSubMenu && icon,
        React.createElement(Container, { className: cx(classes.noWrap, {
                [classes.withIcon]: hasIcon,
            }), flex: true, alignItems: 'center', "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.content }, children),
        hasTag && !hasSubItems && (React.createElement(TagRectangular, { variant: tag.variant || 'red' }, tag.content)),
        hasBadge && !hasSubItems && React.createElement(ItemContentBadge, Object.assign({}, badge)),
        isIndicatorVisible && hasSubItems && (React.createElement(Container, { className: classes.expandedIndicator },
            React.createElement(Indicator, { color: 'red' })))));
};
const SidebarItemContent = (props) => {
    const { children, titleCase: propsTitleCase, compact, isSubMenu, badge, tag, } = props;
    const titleCase = useTitleCase(propsTitleCase);
    const resolvedChildren = resolveChildrenText(children, !!titleCase);
    const hasBadge = badge != null;
    const hasTag = tag != null;
    const isIndicatorVisible = useIndicatorOnParentItem({
        isSubMenu,
        hasBadge,
        hasTag,
    });
    const ItemContentVariant = compact ? CompactItemContent : ExpandedItemContent;
    return (React.createElement(ItemContentVariant, Object.assign({}, props, { isIndicatorVisible: isIndicatorVisible, titleCase: titleCase }), resolvedChildren));
};
export default SidebarItemContent;
//# sourceMappingURL=SidebarItemContent.js.map