var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import cx from 'classnames';
import React, { useCallback, useState } from 'react';
import { makeStyles } from '@material-ui/core/styles';
import styles from './styles';
import Tooltip from '../Tooltip';
import Typography from '../Typography';
import { isOverflown } from '../utils';
const useStyles = makeStyles(styles, {
    name: 'TypographyOverflow',
});
export const TypographyOverflow = (props) => {
    const { children, lines = 1, tooltipContent, tooltipDelay, disableTooltip, className, onClick, onMouseEnter, style } = props, rest = __rest(props, ["children", "lines", "tooltipContent", "tooltipDelay", "disableTooltip", "className", "onClick", "onMouseEnter", "style"]);
    const classes = useStyles(props);
    const [isTooltipActive, setIsTooltipActive] = useState(false);
    const [isTooltipOpened, setIsTooltipOpened] = useState(false);
    const [isTooltipAnimating, setIsTooltipAnimating] = useState(false);
    const isTooltipRendered = isTooltipActive || isTooltipAnimating;
    const isMultiline = lines > 1;
    // We are paying a very high price when using dynamic JSS rules
    // for a component that is used on a very large scale.
    // It was causing a major UI freezes and unnecessary style recalculations,
    // that's why we decided to go with inline styles:
    // https://github.com/toptal/picasso/pull/2110
    const extendedStyle = isMultiline
        ? Object.assign(Object.assign({}, style), { WebkitLineClamp: lines }) : style;
    const handleClick = useCallback((event) => {
        if (!isTooltipOpened &&
            !disableTooltip &&
            isOverflown(event.currentTarget)) {
            setIsTooltipOpened(true);
            setIsTooltipActive(true);
        }
        if (onClick) {
            onClick(event);
        }
    }, [isTooltipOpened, disableTooltip, onClick]);
    const handleMouseEnter = useCallback((event) => {
        if (isOverflown(event.currentTarget)) {
            setIsTooltipActive(true);
            setIsTooltipAnimating(true);
        }
        if (onMouseEnter) {
            onMouseEnter(event);
        }
    }, [onMouseEnter]);
    const handleTooltipOpen = useCallback(() => {
        setIsTooltipOpened(true);
    }, []);
    const handleTooltipClose = useCallback(() => {
        setIsTooltipActive(false);
        setIsTooltipOpened(false);
    }, []);
    const handleTransitionExiting = useCallback(() => {
        setIsTooltipAnimating(true);
    }, []);
    const handleTransitionExited = useCallback(() => {
        setIsTooltipAnimating(false);
    }, []);
    const typography = (React.createElement(Typography, Object.assign({}, rest, { style: extendedStyle, className: cx(classes.wrapper, isMultiline ? classes.multiLine : classes.singleLine, className), onClick: handleClick, onMouseEnter: handleMouseEnter }), children));
    const tooltip = (React.createElement(Tooltip, { open: isTooltipOpened, content: tooltipContent !== null && tooltipContent !== void 0 ? tooltipContent : children, placement: 'top', delay: tooltipDelay, interactive: true, disableListeners: disableTooltip, onOpen: handleTooltipOpen, onClose: handleTooltipClose, onTransitionExiting: handleTransitionExiting, onTransitionExited: handleTransitionExited }, typography));
    return isTooltipRendered ? tooltip : typography;
};
TypographyOverflow.displayName = 'TypographyOverflow';
TypographyOverflow.defaultProps = {
    noWrap: true,
};
export default TypographyOverflow;
//# sourceMappingURL=TypographyOverflow.js.map