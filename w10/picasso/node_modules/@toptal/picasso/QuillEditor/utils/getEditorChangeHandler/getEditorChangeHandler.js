/**
 * When we write block format and enter new empty line, we have unformated text format.
 * We need to send this information to the state
 */
const handleNewLineAfterBlock = ({ quill, onSelectionChange, latestDelta, }) => {
    var _a, _b;
    const latestAttributes = (_b = (_a = latestDelta.ops) === null || _a === void 0 ? void 0 : _a[latestDelta.ops.length - 1]) === null || _b === void 0 ? void 0 : _b.attributes;
    const isHeaderFormatRemoved = (latestAttributes === null || latestAttributes === void 0 ? void 0 : latestAttributes.header) === null;
    const isListFormatRemoved = (latestAttributes === null || latestAttributes === void 0 ? void 0 : latestAttributes.list) === null;
    if (isHeaderFormatRemoved || isListFormatRemoved) {
        const format = quill.getFormat();
        onSelectionChange(Object.assign(Object.assign({}, format), { header: undefined, list: undefined }));
    }
};
const isDeleteOperationOfSelection = (delta) => {
    var _a;
    const delOperation = (_a = delta.ops) === null || _a === void 0 ? void 0 : _a[0].delete;
    return delOperation && delOperation > 1;
};
const getEditorChangeHandler = (quill, onSelectionChange) => {
    const handler = (name, ...args) => {
        if (name === 'text-change') {
            const [latestDelta, , source] = args;
            const isFromApi = source === 'api';
            const isFromUser = source === 'user';
            if (isFromApi) {
                // this event is triggered when format of block element is changed
                // for example from p > h3 | h3 > ol
                onSelectionChange(quill.getFormat());
            }
            else if (isFromUser) {
                handleNewLineAfterBlock({ latestDelta, quill, onSelectionChange });
                if (isDeleteOperationOfSelection(latestDelta)) {
                    onSelectionChange(quill.getFormat());
                }
            }
        }
    };
    return handler;
};
export default getEditorChangeHandler;
//# sourceMappingURL=getEditorChangeHandler.js.map