import React, { forwardRef, useMemo, useRef, useState } from 'react';
import { makeStyles } from '@material-ui/core/styles';
import { useHasMultilineCounter } from '@toptal/picasso-shared';
import cx from 'classnames';
import hastUtilToHtml from 'hast-util-to-html';
import hastSanitize from 'hast-util-sanitize';
import noop from '../utils/noop';
import Container from '../Container';
import QuillEditor from '../QuillEditor';
import InputMultilineAdornment from '../InputMultilineAdornment';
import Toolbar from '../RichTextEditorToolbar';
import styles from './styles';
import { useTextEditorState, useOnSelectionChange, useOnTextFormat, useOnFocus, useToolbarHandlers, useCounter, } from './hooks';
import { usePropDeprecationWarning } from '../utils/use-deprecation-warnings';
const useStyles = makeStyles(styles, {
    name: 'RichTextEditor',
});
export const RichTextEditor = forwardRef(function RichTextEditor(props, ref) {
    const { 'data-testid': dataTestId, plugins, autoFocus = false, className, defaultValue, disabled, id, onChange = noop, onFocus = noop, onBlur = noop, placeholder, minLength, maxLength, minLengthMessage, maxLengthMessage, style, status, testIds, hiddenInputId, setHasMultilineCounter, name, } = props;
    const classes = useStyles();
    const toolbarRef = useRef(null);
    const editorRef = useRef(null);
    const wrapperRef = useRef(null);
    const { dispatch, state } = useTextEditorState();
    usePropDeprecationWarning({
        props,
        name: 'error',
        componentName: 'RichTextEditor',
        description: 'Use the `status` prop instead. `error` is deprecated and will be removed in the next major release.',
    });
    const { handleSelectionChange } = useOnSelectionChange({ dispatch });
    const { handleTextFormat } = useOnTextFormat({ dispatch });
    const { handleBold, handleItalic, handleHeader, handleOrdered, handleUnordered, handleLink, } = useToolbarHandlers({
        editorRef,
        handleTextFormat,
        format: state.toolbar.format,
    });
    const { isEditorFocused, handleFocus, handleBlur } = useOnFocus({
        autoFocus,
        editorRef,
        toolbarRef,
        wrapperRef,
        onFocus,
        onBlur,
        dispatch,
    });
    const [defaultValueInHtml] = useState(() => defaultValue ? hastUtilToHtml(hastSanitize(defaultValue)) : defaultValue);
    const { counterMessage, counterError, handleCounterMessage } = useCounter({
        minLength,
        maxLength,
        minLengthMessage,
        maxLengthMessage,
    });
    // Disabled the exhaustive deps rule to allow users to
    // declare prop like "plugins={[]}" instead of having to
    // declare the array outside the component level
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const memoizedPlugins = useMemo(() => plugins, []);
    useHasMultilineCounter(name, !!counterMessage, setHasMultilineCounter);
    return (React.createElement(React.Fragment, null,
        React.createElement(Container, { className: cx(classes.editorWrapper, {
                [classes.disabled]: disabled,
                [classes.focused]: isEditorFocused,
                [classes.error]: status === 'error',
            }, className), tabIndex: -1, style: style, ref: node => {
                if (typeof ref === 'function') {
                    ref(node);
                }
                else if (ref != null) {
                    ref.current = node;
                }
                wrapperRef.current = node;
            }, "data-testid": (testIds === null || testIds === void 0 ? void 0 : testIds.wrapper) || dataTestId, onFocus: handleFocus, onBlur: handleBlur },
            React.createElement(Toolbar, { ref: toolbarRef, disabled: disabled || state.toolbar.disabled, id: id, format: state.toolbar.format, onBoldClick: handleBold, onItalicClick: handleItalic, onUnorderedClick: handleUnordered, onOrderedClick: handleOrdered, onHeaderChange: handleHeader, onLinkClick: handleLink, plugins: memoizedPlugins, testIds: {
                    headerSelect: testIds === null || testIds === void 0 ? void 0 : testIds.headerSelect,
                    boldButton: testIds === null || testIds === void 0 ? void 0 : testIds.boldButton,
                    italicButton: testIds === null || testIds === void 0 ? void 0 : testIds.italicButton,
                    unorderedListButton: testIds === null || testIds === void 0 ? void 0 : testIds.unorderedListButton,
                    orderedListButton: testIds === null || testIds === void 0 ? void 0 : testIds.orderedListButton,
                } }),
            React.createElement(QuillEditor, { ref: editorRef, disabled: !!disabled, "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.editor, id: id, isFocused: isEditorFocused, placeholder: placeholder, onTextLengthChange: handleCounterMessage, onTextFormat: handleTextFormat, onSelectionChange: handleSelectionChange, onTextChange: onChange, defaultValue: defaultValueInHtml, plugins: memoizedPlugins }),
            hiddenInputId && enableFocusOnLabelClick(hiddenInputId)),
        counterMessage && (React.createElement(InputMultilineAdornment, { error: counterError }, counterMessage))));
});
const hiddenInputStyle = {
    position: 'absolute',
    opacity: 0,
    zIndex: -1,
};
// Native `for` attribute on label does not work for div target
const enableFocusOnLabelClick = (hiddenInputId) => (React.createElement("input", { type: 'text', id: hiddenInputId, style: hiddenInputStyle }));
RichTextEditor.defaultProps = {
    autoFocus: false,
    onChange: noop,
    onFocus: noop,
    onBlur: noop,
    disabled: false,
    status: 'default',
};
RichTextEditor.displayName = 'RichTextEditor';
export default RichTextEditor;
//# sourceMappingURL=RichTextEditor.js.map