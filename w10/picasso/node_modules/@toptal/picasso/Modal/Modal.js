var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, useEffect, useRef, useCallback, } from 'react';
import { makeStyles } from '@material-ui/core/styles';
import { Dialog } from '@material-ui/core';
import cx from 'classnames';
import { usePicassoRoot, useBreakpoint } from '@toptal/picasso-provider';
import { CloseMinor16 } from '../Icon';
import useCombinedRefs from '../utils/use-combined-refs';
import { ModalManager } from '../utils/Modal';
import ButtonCircular from '../ButtonCircular';
import styles from './styles';
import ModalContext from './ModalContext';
import { useBodyScrollLock } from '../utils/use-body-scroll-lock';
const useStyles = makeStyles(styles, {
    name: 'PicassoModal',
});
const defaultManager = new ModalManager();
// https://github.com/udacity/ud891/blob/gh-pages/lesson2-focus/07-modals-and-keyboard-traps/solution/modal.js#L25
// found in https://developers.google.com/web/fundamentals/accessibility/focus/using-tabindex
const focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable]';
const tooltipContainerString = '[role=tooltip]';
const focusFirstFocusableElement = (node) => {
    const elements = node.querySelectorAll(focusableElementsString);
    // Convert NodeList to Array
    const focusableElements = Array.prototype.slice.call(elements);
    focusableElements[0].focus();
};
const isFocusInsideModal = (modalNode) => {
    const modalContainsFocusedElement = modalNode.contains(document.activeElement);
    if (modalContainsFocusedElement) {
        return true;
    }
    return false;
};
const isFocusInsideTooltip = () => {
    const tooltipContainers = document.querySelectorAll(tooltipContainerString);
    if (tooltipContainers.length === 0) {
        return false;
    }
    const tooltipContainsFocusedElement = Array.from(tooltipContainers).some(container => container.contains(document.activeElement));
    if (tooltipContainsFocusedElement) {
        return true;
    }
    return false;
};
const generateKey = (() => {
    let count = 0;
    return () => ++count;
})();
// eslint-disable-next-line react/display-name
export const Modal = forwardRef(function Modal(props, ref) {
    const { children, open, size = 'medium', onBackdropClick, onClose, onOpen, className, style, container, hideBackdrop = false, transitionDuration = 300, paperProps, align = 'centered', testIds, transitionProps, disableBackdropClick = false } = props, rest = __rest(props, ["children", "open", "size", "onBackdropClick", "onClose", "onOpen", "className", "style", "container", "hideBackdrop", "transitionDuration", "paperProps", "align", "testIds", "transitionProps", "disableBackdropClick"]);
    const classes = useStyles(props);
    const picassoRootContainer = usePicassoRoot();
    const rootRef = useCombinedRefs(ref, useRef(null));
    const modalId = useRef(generateKey());
    useEffect(() => {
        const handleDocumentFocus = () => {
            if (!defaultManager.isTopModal(modalId.current)) {
                return;
            }
            if (!rootRef || !rootRef.current) {
                return;
            }
            if (isFocusInsideModal(rootRef.current)) {
                return;
            }
            if (isFocusInsideTooltip()) {
                return;
            }
            focusFirstFocusableElement(rootRef.current);
        };
        if (!open) {
            return;
        }
        document.addEventListener('focus', handleDocumentFocus, true);
        return () => {
            document.removeEventListener('focus', handleDocumentFocus, true);
        };
    }, [open, rootRef]);
    useEffect(() => {
        const currentModalId = modalId.current;
        if (open) {
            defaultManager.add(currentModalId);
        }
        return () => {
            defaultManager.remove(currentModalId);
        };
    }, [open]);
    useBodyScrollLock(open);
    const isSmall = useBreakpoint('small');
    const handleClose = useCallback((_event, reason) => {
        if (reason === 'escapeKeyDown' && onClose) {
            onClose();
        }
        else if (reason === 'backdropClick' && !disableBackdropClick) {
            if (onBackdropClick) {
                onBackdropClick();
            }
            if (onClose) {
                onClose();
            }
        }
    }, [disableBackdropClick, onBackdropClick, onClose]);
    return (React.createElement(Dialog, Object.assign({}, rest, { ref: rootRef, classes: {
            root: classes.root,
            container: classes.container,
            paper: cx(classes.paper, classes[size], {
                [classes.topAlignedDialog]: align === 'top',
            }),
        }, className: className, style: style, fullScreen: isSmall, container: container || picassoRootContainer, PaperProps: Object.assign(Object.assign({}, paperProps), { elevation: 2 }), hideBackdrop: hideBackdrop, onClose: handleClose, onEnter: onOpen, open: open, transitionDuration: transitionDuration, maxWidth: false, disableEnforceFocus // we need our own mechanism to keep focus inside the Modals
        : true, TransitionProps: transitionProps }),
        React.createElement(ModalContext.Provider, { value: true }, children),
        onClose && (React.createElement(ButtonCircular, { variant: 'flat', className: classes.closeButton, onClick: onClose, "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.closeButton },
            React.createElement(CloseMinor16, null)))));
});
Modal.defaultProps = {
    hideBackdrop: false,
    disableBackdropClick: false,
    size: 'medium',
    transitionDuration: 300,
    align: 'centered',
};
Modal.displayName = 'Modal';
export default Modal;
//# sourceMappingURL=Modal.js.map