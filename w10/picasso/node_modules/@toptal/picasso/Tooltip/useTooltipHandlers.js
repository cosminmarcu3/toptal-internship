import { cloneElement, useState, } from 'react';
export const useTooltipHandlers = ({ onClose, onOpen, onMouseOver, onMouseMove, onClick, tooltipState, disableListeners, children, }) => {
    const { isOpen, isControlled, isTouchDevice, targetHoveredRef, openTooltip, closeTooltip, } = tooltipState;
    // After closing with click the tooltip should not be opened againg until the mouse leave event
    const [ignoreOpening, setIgnoreOpening] = useState(false);
    if (isControlled) {
        return {
            handleOpen: onOpen,
            handleClose: onClose,
            children,
        };
    }
    const handleClose = (event) => {
        onClose === null || onClose === void 0 ? void 0 : onClose(event);
        closeTooltip();
    };
    const handleOpen = (event) => {
        if (ignoreOpening) {
            return;
        }
        onOpen === null || onOpen === void 0 ? void 0 : onOpen(event);
        openTooltip();
    };
    const handleClick = (event) => {
        var _a, _b;
        (_b = (_a = children.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, event);
        if (disableListeners) {
            return;
        }
        if (isOpen) {
            setIgnoreOpening(true);
            handleClose(event);
        }
        else if (isTouchDevice) {
            handleOpen(event);
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
    };
    const handleMouseOver = (event) => {
        var _a, _b;
        (_b = (_a = children.props).onMouseOver) === null || _b === void 0 ? void 0 : _b.call(_a, event);
        if (disableListeners) {
            return;
        }
        targetHoveredRef.current = true;
        onMouseOver === null || onMouseOver === void 0 ? void 0 : onMouseOver(event);
    };
    const handleMouseMove = (event) => {
        var _a, _b;
        (_b = (_a = children.props).onMouseMove) === null || _b === void 0 ? void 0 : _b.call(_a, event);
        if (disableListeners) {
            return;
        }
        onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(event);
    };
    const handleMouseLeave = (event) => {
        var _a, _b;
        (_b = (_a = children.props).onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, event);
        if (disableListeners) {
            return;
        }
        targetHoveredRef.current = false;
        setIgnoreOpening(false);
    };
    return {
        handleOpen,
        handleClose,
        children: cloneElement(children, {
            onClick: handleClick,
            onMouseOver: handleMouseOver,
            onMouseMove: handleMouseMove,
            onMouseLeave: handleMouseLeave,
        }),
    };
};
//# sourceMappingURL=useTooltipHandlers.js.map