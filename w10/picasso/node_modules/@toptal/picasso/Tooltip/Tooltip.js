var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, } from 'react';
import { makeStyles } from '@material-ui/core/styles';
import { Tooltip as MUITooltip } from '@material-ui/core';
import cx from 'classnames';
import { usePicassoRoot } from '@toptal/picasso-provider';
import Typography from '../Typography';
import styles from './styles';
import { useTooltipState } from './useTooltipState';
import { useTooltipHandlers } from './useTooltipHandlers';
import { useTooltipFollowCursor } from './useTooltipFollowCursor';
const delayDurations = {
    short: 200,
    long: 500,
};
const getDelayDuration = (delay, isTouchDevice) => {
    return isTouchDevice ? 0 : delayDurations[delay];
};
const useStyles = makeStyles(styles, { name: 'PicassoTooltip' });
export const Tooltip = forwardRef((props, ref) => {
    const { content, children: originalChildren, placement, interactive, className, style, open, onOpen, onClose, onTransitionExiting, onTransitionExited, disableListeners, preventOverflow, disablePortal, delay = 'short', compact, maxWidth, followCursor = false, tooltipRef, container } = props, rest = __rest(props, ["content", "children", "placement", "interactive", "className", "style", "open", "onOpen", "onClose", "onTransitionExiting", "onTransitionExited", "disableListeners", "preventOverflow", "disablePortal", "delay", "compact", "maxWidth", "followCursor", "tooltipRef", "container"]);
    const classes = useStyles();
    const picassoRootContainer = usePicassoRoot();
    const tooltipState = useTooltipState({ externalOpen: open, followCursor });
    const delayDuration = getDelayDuration(delay, tooltipState.isTouchDevice);
    const followCursorTooltipData = useTooltipFollowCursor({
        followCursor,
        tooltipState,
    });
    const { children, handleOpen, handleClose } = useTooltipHandlers({
        children: originalChildren,
        tooltipState,
        disableListeners,
        onOpen,
        onClose,
        onMouseOver: followCursorTooltipData === null || followCursorTooltipData === void 0 ? void 0 : followCursorTooltipData.handleMouseOver,
        onMouseMove: followCursorTooltipData === null || followCursorTooltipData === void 0 ? void 0 : followCursorTooltipData.handleMouseMove,
        onClick: followCursorTooltipData === null || followCursorTooltipData === void 0 ? void 0 : followCursorTooltipData.handleClick,
    });
    const title = (React.createElement(Typography, { as: 'div', size: 'small', color: 'inherit' }, content));
    return (React.createElement(MUITooltip, Object.assign({}, rest, { ref: ref, arrow: !compact && !followCursor, PopperProps: Object.assign({ ref: tooltipRef, container: container || picassoRootContainer, disablePortal, popperOptions: {
                modifiers: {
                    preventOverflow: {
                        enabled: preventOverflow,
                        boundariesElement: 'window',
                    },
                    hide: {
                        enabled: preventOverflow,
                    },
                },
            } }, (followCursor && (followCursorTooltipData === null || followCursorTooltipData === void 0 ? void 0 : followCursorTooltipData.followCursorPopperProps))), TransitionProps: Object.assign(Object.assign({}, (onTransitionExiting && { onExiting: onTransitionExiting })), (onTransitionExited && { onExiting: onTransitionExited })), classes: {
            arrow: classes.arrow,
            tooltip: cx(classes.tooltip, {
                [classes.light]: !compact,
                [classes.compact]: compact,
                [classes.noMaxWidth]: maxWidth === 'none',
            }),
        }, className: className, style: style, interactive: interactive, onClose: handleClose, onOpen: handleOpen, open: tooltipState.isOpen, placement: placement, title: title, disableHoverListener: disableListeners, disableFocusListener: disableListeners, disableTouchListener: true, enterDelay: delayDuration, enterNextDelay: delayDuration }), children));
});
Tooltip.defaultProps = {
    preventOverflow: true,
    placement: 'top',
    disablePortal: false,
    maxWidth: 'default',
    delay: 'short',
};
export default Tooltip;
//# sourceMappingURL=Tooltip.js.map