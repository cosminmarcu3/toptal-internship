import { useCallback, useRef } from 'react';
import debounce from 'debounce';
export const mouseMoveDebounceTimeout = 250;
export const mouseMoveCloseTooltipDistance = 50;
const isMouseMovedTooFar = (positionA, positionB) => Math.abs(positionA.x - positionB.x) > mouseMoveCloseTooltipDistance ||
    Math.abs(positionA.y - positionB.y) > mouseMoveCloseTooltipDistance;
export const useTooltipFollowCursor = ({ followCursor, tooltipState, }) => {
    const { targetHoveredRef, openTooltip, closeTooltip } = tooltipState;
    const positionRef = useRef({ x: 0, y: 0 });
    const mouseMoveStartPositionRef = useRef(null);
    const popperRef = useRef(null);
    const handleMouseStop = useCallback(() => {
        if (targetHoveredRef.current) {
            mouseMoveStartPositionRef.current = null;
            openTooltip();
        }
    }, [targetHoveredRef]);
    const handleMouseStopDebounced = useCallback(debounce(handleMouseStop, mouseMoveDebounceTimeout), [debounce, handleMouseStop]);
    const calculateTooltipPosition = (event) => {
        var _a;
        if (!mouseMoveStartPositionRef.current) {
            mouseMoveStartPositionRef.current = { x: event.clientX, y: event.clientY };
        }
        positionRef.current = { x: event.clientX, y: event.clientY };
        (_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
    };
    const handleMouseMove = (event) => {
        var _a;
        calculateTooltipPosition(event);
        const shouldCloseTooltip = isMouseMovedTooFar(positionRef.current, (_a = mouseMoveStartPositionRef === null || mouseMoveStartPositionRef === void 0 ? void 0 : mouseMoveStartPositionRef.current) !== null && _a !== void 0 ? _a : positionRef.current);
        // When the cursor is moved `mouseMoveCloseTooltipDistance` pixels and more in any direction, we close the tooltip
        // We need it because when the cursor is moved to a long distance, the tooltip becomes annoying
        if (shouldCloseTooltip) {
            closeTooltip();
        }
        handleMouseStopDebounced();
    };
    if (!followCursor) {
        return undefined;
    }
    return {
        handleMouseMove,
        handleMouseOver: calculateTooltipPosition,
        handleClick: calculateTooltipPosition,
        followCursorPopperProps: {
            popperRef,
            modifiers: {
                offset: {
                    enabled: true,
                    offset: '0px,10px',
                },
            },
            anchorEl: {
                clientHeight: 0,
                clientWidth: 0,
                getBoundingClientRect: () => ({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    top: positionRef.current.y,
                    left: positionRef.current.x,
                    right: positionRef.current.x,
                    bottom: positionRef.current.y,
                    // this field required according to types
                    toJSON: () => { },
                }),
            },
        },
    };
};
//# sourceMappingURL=useTooltipFollowCursor.js.map