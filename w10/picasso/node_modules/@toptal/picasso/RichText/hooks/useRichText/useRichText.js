var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import toH from 'hast-to-hyperscript';
import React, { useMemo, createElement, isValidElement, } from 'react';
import Typography from '../../../Typography';
import Container from '../../../Container';
import List from '../../../List';
import ListItem from '../../../ListItem';
import Link from '../../../Link';
// List internaly passes another props to ListItem
const Li = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    return (React.createElement(ListItem, Object.assign({}, props), children));
};
/* eslint-disable id-length */
const P = ({ children }) => (React.createElement(Typography, { size: 'small' }, children));
const Strong = ({ children }) => (React.createElement(Typography, { size: 'small', as: 'strong', weight: 'semibold' }, children));
const Em = ({ children }) => (React.createElement(Typography, { size: 'small', as: 'em' }, children));
const H3 = ({ children }) => (React.createElement(Container, { top: 'xsmall' },
    React.createElement(Typography, { as: 'h3', variant: 'heading', size: 'medium' }, children)));
const Ul = ({ children }) => React.createElement(List, { variant: 'unordered' }, children);
const Ol = ({ children }) => React.createElement(List, { variant: 'ordered' }, children);
const A = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    return React.createElement(Link, Object.assign({}, props), children);
};
const componentMap = {
    p: P,
    strong: Strong,
    em: Em,
    h3: H3,
    li: Li,
    ol: Ol,
    ul: Ul,
    a: A,
};
const picassoMapper = (child) => {
    var _a, _b;
    if (!isValidElement(child)) {
        return child;
    }
    const type = componentMap[child.type] || child.type;
    const mappedChildren = (_b = (_a = child.props.children) === null || _a === void 0 ? void 0 : _a.map(picassoMapper)) !== null && _b !== void 0 ? _b : null;
    return createElement(type, Object.assign(Object.assign({}, child.props), { key: child.key }), mappedChildren);
};
const useRichText = (value) => {
    const mappedTextNodes = useMemo(() => {
        const { children: astChildren } = value;
        if (!(astChildren === null || astChildren === void 0 ? void 0 : astChildren.length)) {
            return null;
        }
        const isSingleChild = astChildren.length === 1;
        const reactElement = toH(createElement, value);
        if (isSingleChild) {
            return picassoMapper(reactElement);
        }
        // first node of tree is always "root",
        // which is transformed to wrapping div when children.length > 1
        // when single children, there is no wrapping div and it returns textNode right away
        const textNodes = reactElement.props.children;
        return textNodes.map(picassoMapper);
    }, [value]);
    return mappedTextNodes;
};
export default useRichText;
//# sourceMappingURL=useRichText.js.map