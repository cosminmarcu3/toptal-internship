var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/* eslint-disable max-lines */
import React, { forwardRef, } from 'react';
import cx from 'classnames';
import { makeStyles } from '@material-ui/core/styles';
import { useHasMultilineCounter, } from '@toptal/picasso-shared';
import OutlinedInput from '../OutlinedInput';
import { disableUnsupportedProps } from '../utils';
import styles from './styles';
import { usePropDeprecationWarning } from '../utils/use-deprecation-warnings';
import InputLimitAdornment from '../InputLimitAdornment';
import InputIconAdornment from '../InputIconAdornment';
import Container from '../Container';
import InputValidIconAdornment from '../InputValidIconAdornment';
const useStyles = makeStyles(styles, { name: 'PicassoInput' });
const hasRemainingCounter = ({ counter, limit, }) => Boolean(counter === 'remaining' && limit);
const hasEnteredCounter = ({ counter }) => counter === 'entered';
const hasCounter = ({ counter, limit }) => hasRemainingCounter({ counter, limit }) || hasEnteredCounter({ counter });
const hasMultilineAdornment = ({ multiline, status, counter, limit, }) => multiline && (status === 'success' || hasCounter({ counter, limit }));
const StartAdornment = ({ icon, iconPosition, disabled, }) => {
    if (!icon || iconPosition !== 'start') {
        return null;
    }
    return React.createElement(InputIconAdornment, { disabled: disabled, position: 'start', icon: icon });
};
const EndAdornment = (props) => {
    const { icon, iconPosition, disabled, limit, multiline, charsLength, testIds, counter, showCounter, } = props;
    if (icon && iconPosition === 'end') {
        return React.createElement(InputIconAdornment, { disabled: disabled, position: 'end', icon: icon });
    }
    if (!multiline && showCounter) {
        return (React.createElement(InputLimitAdornment
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        , { 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            charsLength: charsLength, multiline: multiline, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            counter: counter, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            limit: limit, testIds: testIds }));
    }
    return null;
};
const MultilineAdornment = ({ charsLength, counter, limit, showCounter, status, testIds, }) => {
    return (React.createElement(Container, { flex: true },
        showCounter && (React.createElement(InputLimitAdornment, { testIds: testIds, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            charsLength: charsLength, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            counter: counter, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            limit: limit, multiline: true })),
        status === 'success' && (React.createElement(InputValidIconAdornment, { "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.validIcon, multiline: true }))));
};
const purifyProps = (props) => {
    const sizeOptions = {
        featureProps: {
            size: 'small',
        },
        unsupportedProps: {
            multiline: false,
            icon: undefined,
            startAdornment: undefined,
            endAdornment: undefined,
            limit: undefined,
        },
    };
    return disableUnsupportedProps('Input', props, sizeOptions);
};
export const Input = forwardRef(function Input(props, ref) {
    const _a = purifyProps(props), { id, name, defaultValue, value, placeholder, error, status, disabled, icon, iconPosition, inputProps, children, multiline, multilineResizable, autoFocus, width, className, style, rows, rowsMax, type, onChange, onClick, startAdornment, endAdornment, limit, counter, size, enableReset, onResetClick, outlineRef, testIds, setHasMultilineCounter, highlightAutofill } = _a, rest = __rest(_a, ["id", "name", "defaultValue", "value", "placeholder", "error", "status", "disabled", "icon", "iconPosition", "inputProps", "children", "multiline", "multilineResizable", "autoFocus", "width", "className", "style", "rows", "rowsMax", "type", "onChange", "onClick", "startAdornment", "endAdornment", "limit", "counter", "size", "enableReset", "onResetClick", "outlineRef", "testIds", "setHasMultilineCounter", "highlightAutofill"]);
    usePropDeprecationWarning({
        props,
        name: 'error',
        componentName: 'Input',
        description: 'Use the `status` prop instead. `error` is deprecated and will be removed in the next major release.',
    });
    const charsLength = value ? value.length : 0;
    const classes = useStyles();
    const showCounter = !!charsLength && hasCounter({ counter, limit });
    useHasMultilineCounter(name, showCounter && multiline, setHasMultilineCounter);
    return (React.createElement(React.Fragment, null,
        React.createElement(OutlinedInput, { ref: outlineRef, inputRef: ref, className: className, style: style, classes: {
                root: cx(classes.root, {
                    [classes.rootMultiline]: multiline,
                    [classes.highlightAutofill]: highlightAutofill,
                }),
                input: cx(classes.input, {
                    [classes.inputMultilineResizable]: multiline && multilineResizable,
                }),
            }, id: id, name: name, defaultValue: defaultValue, value: value, placeholder: placeholder, status: error ? 'error' : status, disabled: disabled, multiline: multiline, autoFocus: autoFocus, rows: rows, rowsMax: rowsMax, type: type, width: width, size: size, onClick: onClick, 
            // html attributes
            inputProps: Object.assign(Object.assign({}, rest), inputProps), startAdornment: startAdornment || (React.createElement(StartAdornment, { icon: icon, iconPosition: iconPosition, disabled: disabled })), endAdornment: endAdornment || (React.createElement(EndAdornment, { icon: icon, iconPosition: iconPosition, disabled: disabled, limit: limit, charsLength: charsLength, multiline: multiline, counter: counter, status: status, testIds: testIds, showCounter: showCounter })), onChange: onChange, enableReset: enableReset, onResetClick: onResetClick, testIds: testIds }, children),
        hasMultilineAdornment({
            multiline,
            status,
            limit,
            counter,
        }) && (React.createElement(MultilineAdornment, { charsLength: charsLength, status: status, testIds: testIds, showCounter: showCounter, counter: counter, limit: limit }))));
});
Input.defaultProps = {
    autoComplete: 'none',
    counter: 'remaining',
    iconPosition: 'start',
    highlightAutofill: false,
    multiline: false,
    size: 'medium',
    width: 'auto',
    onChange: () => { },
    onResetClick: () => { },
    status: 'default',
};
Input.displayName = 'Input';
export default Input;
//# sourceMappingURL=Input.js.map