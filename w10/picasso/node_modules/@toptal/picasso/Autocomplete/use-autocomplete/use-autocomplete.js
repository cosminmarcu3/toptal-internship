/* eslint-disable complexity, max-statements */ // Squiggly lines makes code difficult to work with
import { useState, useEffect, useMemo, } from 'react';
export const EMPTY_INPUT_VALUE = '';
export const INITIAL_HIGHLIGHT_INDEX = 0;
export const normalizeInitialIndex = ({ initialIndex, itemCount, moveAmount, }) => {
    const outOfBounds = initialIndex < 0 || initialIndex >= itemCount;
    if (outOfBounds) {
        const lastIndex = itemCount - 1;
        return moveAmount > 0 ? -1 : lastIndex + 1;
    }
    return initialIndex;
};
/**
 * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,
 * it will wrap to either 0 or itemCount - 1.
 *
 * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
 * @param {number} initialIndex The initial position to move from.
 * @param {number} itemCount The total number of items.
 * @returns {number} The new index after the move.
 */
export const getNextWrappingIndex = (moveAmount, initialIndex, itemCount) => {
    const lastIndex = itemCount - 1;
    const normalizedInitialIndex = normalizeInitialIndex({
        initialIndex,
        itemCount,
        moveAmount,
    });
    const newIndex = normalizedInitialIndex + moveAmount;
    if (newIndex < 0) {
        return lastIndex;
    }
    if (newIndex > lastIndex) {
        return 0;
    }
    return newIndex;
};
export const useAutocomplete = ({ value, options = [], closeOnSelect = true, onChange = () => { }, onKeyDown = () => { }, onFocus = () => { }, onBlur = () => { }, onSelect = () => { }, onOtherOptionSelect = () => { }, onResetClick = () => { }, getDisplayValue, enableReset, showOtherOption, disabled = false, ref, }) => {
    const [isOpen, setOpen] = useState(false);
    const [highlightedIndex, setHighlightedIndex] = useState(INITIAL_HIGHLIGHT_INDEX);
    const selectedIndex = useMemo(() => value && Array.isArray(options)
        ? options.findIndex(option => getDisplayValue(option) === value)
        : null, [getDisplayValue, options, value]);
    useEffect(() => {
        if (!isOpen) {
            const newHighlightedIndex = selectedIndex && selectedIndex !== -1 ? selectedIndex : 0;
            if (newHighlightedIndex !== highlightedIndex) {
                setHighlightedIndex(newHighlightedIndex);
            }
        }
    }, [isOpen, selectedIndex, highlightedIndex]);
    useEffect(() => {
        if (typeof ref === 'function' || !isOpen || !(ref === null || ref === void 0 ? void 0 : ref.current)) {
            return;
        }
        if (document.activeElement !== ref.current) {
            ref.current.focus();
        }
    }, [isOpen, ref]);
    const shouldShowOtherOption = Boolean(showOtherOption) && selectedIndex === -1;
    const handleChange = (newValue, isSelected = false) => {
        if (newValue !== value) {
            onChange(newValue, { isSelected });
        }
    };
    const handleSelect = (item, event) => {
        const displayValue = getDisplayValue(item);
        if (item === null || displayValue === null) {
            return;
        }
        onSelect(item, event);
    };
    const getBaseItemProps = (index) => ({
        role: 'option',
        'aria-selected': highlightedIndex === index,
        selected: highlightedIndex === index,
        onMouseMove: () => {
            if (index === highlightedIndex) {
                return;
            }
            setHighlightedIndex(index);
        },
        onMouseDown: (event) => {
            // This prevents the activeElement from being changed
            // to the item so it can remain with the current activeElement
            // which is a more common use case.
            event.preventDefault();
        },
    });
    const getItemProps = (index, item) => (Object.assign(Object.assign({}, getBaseItemProps(index)), { onClick: (event) => {
            if (closeOnSelect) {
                setOpen(false);
            }
            handleChange(getDisplayValue(item), true);
            handleSelect(item, event);
        } }));
    const getOtherItemProps = (index, newValue) => (Object.assign(Object.assign({}, getBaseItemProps(index)), { onClick: (event) => {
            if (closeOnSelect) {
                setOpen(false);
            }
            onOtherOptionSelect(newValue, event);
        } }));
    const handleClick = () => {
        if (isOpen || disabled) {
            return;
        }
        setOpen(true);
    };
    const handleBlur = event => {
        setOpen(false);
        onBlur(event);
    };
    const getInputProps = () => ({
        'aria-autocomplete': 'list',
        onFocus,
        onClick: handleClick,
        onChange: (event) => {
            setOpen(true);
            handleChange(event.target.value);
        },
        onKeyDown: (event) => {
            var _a;
            onKeyDown(event, value);
            const optionsCount = (options === null || options === void 0 ? void 0 : options.length) || 0;
            const otherOptionsCount = shouldShowOtherOption ? 1 : 0;
            const itemsCount = optionsCount + otherOptionsCount;
            if (event.key === 'ArrowUp') {
                event.preventDefault();
                setOpen(true);
                setHighlightedIndex(getNextWrappingIndex(-1, highlightedIndex, itemsCount));
            }
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                setOpen(true);
                setHighlightedIndex(getNextWrappingIndex(1, highlightedIndex, itemsCount));
            }
            if (event.key === 'Backspace') {
                if (value !== EMPTY_INPUT_VALUE) {
                    return;
                }
                if (closeOnSelect) {
                    setOpen(false);
                }
                handleChange(getDisplayValue(null));
            }
            if (event.key === 'Enter') {
                event.preventDefault();
                if (!isOpen) {
                    setOpen(true);
                    return;
                }
                if (closeOnSelect) {
                    setOpen(false);
                }
                const findSelectedItemUsingIndex = () => highlightedIndex === null ? undefined : options === null || options === void 0 ? void 0 : options[highlightedIndex];
                const findSelectedItemUsingValue = () => options === null || options === void 0 ? void 0 : options.find(option => option.text === value);
                const selectedItem = (_a = findSelectedItemUsingIndex()) !== null && _a !== void 0 ? _a : findSelectedItemUsingValue();
                if (selectedItem) {
                    handleChange(getDisplayValue(selectedItem), true);
                    handleSelect(selectedItem, event);
                }
                else if (value) {
                    onOtherOptionSelect(value, event);
                }
            }
            if (event.key === 'Escape') {
                event.preventDefault();
                setOpen(false);
                handleChange(getDisplayValue(null));
            }
        },
        onBlur: handleBlur,
        enableReset,
        onResetClick: (event) => {
            event.stopPropagation();
            handleChange(getDisplayValue(null));
            onResetClick(event);
        },
    });
    return {
        getItemProps,
        getOtherItemProps,
        getInputProps,
        isOpen,
        highlightedIndex,
        shouldShowOtherOption,
    };
};
//# sourceMappingURL=use-autocomplete.js.map