/* eslint-disable max-lines */
/* eslint-disable complexity, max-statements, max-lines-per-function */ // Squiggly lines makes code difficult to work with
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, useRef, } from 'react';
import { makeStyles } from '@material-ui/core/styles';
import capitalize from '@material-ui/core/utils/capitalize';
import cx from 'classnames';
import { isForwardRef } from '@toptal/picasso-shared';
import Input from '../Input';
import { MenuCompound as Menu } from '../MenuCompound';
import Container from '../Container';
import Loader from '../Loader';
import SelectOptions from '../SelectOptions';
import Popper from '../Popper';
import InputAdornment from '../InputAdornment';
import PoweredByGoogle from './PoweredByGoogle';
import NoOptionsMenuItem from './NoOptionsMenuItem';
import OtherOptionMenuItem from './OtherOptionMenuItem';
import { useAutocomplete, EMPTY_INPUT_VALUE } from './use-autocomplete';
import styles from './styles';
import unsafeErrorLog from '../utils/unsafe-error-log';
import { usePropDeprecationWarning } from '../utils/use-deprecation-warnings';
const useStyles = makeStyles(styles, {
    name: 'PicassoAutocomplete',
});
const getItemText = (item) => (item && item.text) || EMPTY_INPUT_VALUE;
export const Autocomplete = forwardRef(function Autocomplete(props, customRef) {
    const { autoComplete, className, enableAutofill, enableReset, endAdornment, error, status, getDisplayValue = getItemText, getKey: customGetKey, icon, inputComponent, loading, menuWidth, name, noOptionsText = 'No options', closeOnSelect, onBlur, onChange, onFocus, onKeyDown, onOtherOptionSelect, onResetClick, onSelect, options, otherOptionText = 'Other option: ', placeholder, popperContainer, popperOptions, poweredByGoogle, renderOption, renderOtherOption, showOtherOption, style, testIds, value, width = 'auto', disabled = false } = props, rest = __rest(props, ["autoComplete", "className", "enableAutofill", "enableReset", "endAdornment", "error", "status", "getDisplayValue", "getKey", "icon", "inputComponent", "loading", "menuWidth", "name", "noOptionsText", "closeOnSelect", "onBlur", "onChange", "onFocus", "onKeyDown", "onOtherOptionSelect", "onResetClick", "onSelect", "options", "otherOptionText", "placeholder", "popperContainer", "popperOptions", "poweredByGoogle", "renderOption", "renderOtherOption", "showOtherOption", "style", "testIds", "value", "width", "disabled"]);
    const inputRef = useRef(null);
    let ref = customRef || inputRef;
    if (inputComponent && !isForwardRef(inputComponent)) {
        ref = undefined;
        unsafeErrorLog('You provided `inputComponent` prop to Autocomplete without using React.forwardRef wrapper. This is not supported and may cause unexpected behavior. Consider wrapping your input component with React.forwardRef.');
    }
    usePropDeprecationWarning({
        props,
        name: 'error',
        componentName: 'Autocomplete',
        description: 'Use the `status` prop instead. `error` is deprecated and will be removed in the next major release.',
    });
    const classes = useStyles();
    const getKey = (item) => {
        if (customGetKey) {
            return customGetKey(item);
        }
        const displayValue = getDisplayValue(item);
        if (!displayValue) {
            unsafeErrorLog('Autocomplete expects you to provide key prop value with getKey or Item.value!');
        }
        return displayValue;
    };
    const { highlightedIndex, isOpen, shouldShowOtherOption, getItemProps, getOtherItemProps, getInputProps, } = useAutocomplete({
        value,
        disabled,
        options,
        closeOnSelect,
        getDisplayValue,
        onSelect,
        onOtherOptionSelect,
        onResetClick,
        onChange,
        onKeyDown,
        onFocus,
        onBlur,
        enableReset,
        showOtherOption,
        ref,
    });
    const optionsLength = options ? options.length : 0;
    const optionsMenu = options && (React.createElement(SelectOptions, { "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.scrollMenu, selectedIndex: highlightedIndex, fixedFooter: optionsLength > 0 &&
            poweredByGoogle && React.createElement(PoweredByGoogle, { classes: classes }) }, options === null || options === void 0 ? void 0 :
        options.map((option, index) => (React.createElement(Menu.Item, Object.assign({ "data-testid": (testIds === null || testIds === void 0 ? void 0 : testIds.menuItem) ? `${testIds === null || testIds === void 0 ? void 0 : testIds.menuItem}-${index}` : undefined, key: getKey(option) }, getItemProps(index, option), { titleCase: false, description: option.description, className: classes.option }), renderOption
            ? renderOption(option, index)
            : getDisplayValue(option)))),
        shouldShowOtherOption && (React.createElement(OtherOptionMenuItem, Object.assign({ "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.otherOption, value: value, classes: classes, renderOtherOption: renderOtherOption, otherOptionText: otherOptionText }, getOtherItemProps(optionsLength, value)))),
        !optionsLength && !shouldShowOtherOption && noOptionsText && (React.createElement(NoOptionsMenuItem, { "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.noOptions }, noOptionsText))));
    const InputComponent = inputComponent || Input;
    const loadingComponent = (React.createElement(InputAdornment, { "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.loadingAdornment, position: 'end', disablePointerEvents: true },
        React.createElement(Loader, { size: 'small' })));
    const inputWrapperRef = useRef(null);
    const inputProps = getInputProps();
    return (React.createElement("div", { className: cx(classes.root, className, classes[`root${capitalize(width)}`]), style: style, role: 'combobox', "aria-expanded": isOpen, "aria-haspopup": 'listbox' },
        React.createElement(Container, { flex: true, ref: inputWrapperRef, onClick: inputProps.onClick },
            !enableAutofill && name && (React.createElement("input", { type: 'hidden', value: value, name: name, "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.disableAutofillInput })),
            React.createElement(InputComponent, Object.assign({}, rest, inputProps, { status: error ? 'error' : status, icon: icon, disabled: disabled, defaultValue: undefined, value: value, ref: ref, placeholder: placeholder, inputProps: rest.inputProps, endAdornment: loading ? loadingComponent : endAdornment, width: width, name: enableAutofill ? name : undefined, autoComplete: enableAutofill ? autoComplete : autoComplete || 'off', testIds: testIds, "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.input }))),
        React.createElement("div", { role: 'listbox' }, isOpen && inputWrapperRef.current && optionsMenu && (React.createElement(Popper, { autoWidth: true, width: menuWidth, placement: 'bottom-start', open: isOpen && !loading, anchorEl: inputWrapperRef.current, container: popperContainer, popperOptions: popperOptions }, optionsMenu)))));
});
Autocomplete.defaultProps = {
    enableAutofill: false,
    getDisplayValue: getItemText,
    loading: false,
    noOptionsText: 'No options',
    onChange: () => { },
    onKeyDown: () => { },
    onFocus: () => { },
    onBlur: () => { },
    onOtherOptionSelect: () => { },
    onResetClick: () => { },
    onSelect: () => { },
    options: [],
    otherOptionText: 'Other option: ',
    showOtherOption: false,
    width: 'auto',
    enableReset: true,
    poweredByGoogle: false,
    disabled: false,
    status: 'default',
};
Autocomplete.displayName = 'Autocomplete';
export default Autocomplete;
//# sourceMappingURL=Autocomplete.js.map