var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/* eslint-disable max-lines-per-function, max-lines */
/* eslint-disable complexity, max-statements */ // Squiggly lines makes code difficult to work with
import { makeStyles } from '@material-ui/core/styles';
import formatDate from 'date-fns/format';
import React, { useCallback, useEffect, useMemo, useRef, useState, } from 'react';
import { Calendar16 } from '../Icon';
import Popper from '../Popper';
import Container from '../Container';
import Input from '../Input';
import InputAdornment from '../InputAdornment';
import { noop } from '../utils';
import Calendar from '../Calendar';
import { DEFAULT_DATE_PICKER_DISPLAY_DATE_FORMAT, DEFAULT_DATE_PICKER_EDIT_DATE_FORMAT, DEFAULT_POPPER_OPTIONS, } from './constants';
import styles from './styles';
import { formatDateRange, datePickerParseDateString, timezoneConvert, timezoneFormat, getStartOfTheDayDate, } from './utils';
import { usePropDeprecationWarning } from '../utils/use-deprecation-warnings';
const EMPTY_INPUT_VALUE = '';
const useStyles = makeStyles(styles, {
    name: 'PicassoDatePicker',
});
export const DatePicker = (props) => {
    const { range, hideOnSelect, displayDateFormat = DEFAULT_DATE_PICKER_DISPLAY_DATE_FORMAT, editDateFormat = DEFAULT_DATE_PICKER_EDIT_DATE_FORMAT, onBlur = noop, onChange, onResetClick, value, width, icon, minDate, maxDate, disabledIntervals, popperContainer, renderDay, weekStartsOn, timezone, size, parseInputValue, testIds, error, status, popperProps, disabled, footer, indicatedIntervals, footerBackgroundColor } = props, rest = __rest(props, ["range", "hideOnSelect", "displayDateFormat", "editDateFormat", "onBlur", "onChange", "onResetClick", "value", "width", "icon", "minDate", "maxDate", "disabledIntervals", "popperContainer", "renderDay", "weekStartsOn", "timezone", "size", "parseInputValue", "testIds", "error", "status", "popperProps", "disabled", "footer", "indicatedIntervals", "footerBackgroundColor"]);
    const classes = useStyles();
    usePropDeprecationWarning({
        props,
        name: 'error',
        componentName: 'DatePicker',
        description: 'Use the `status` prop instead. `error` is deprecated and will be removed in the next major release.',
    });
    const inputProps = rest;
    const [calendarIsShown, setCalendarIsShown] = useState(false);
    const [isInputFocused, setIsInputFocused] = useState(false);
    const [inputValue, setInputValue] = useState(EMPTY_INPUT_VALUE);
    const [calendarValue, setCalendarValue] = useState(null);
    const [normalizedMinDate, normalizedMaxDate] = useMemo(() => {
        return [getStartOfTheDayDate(minDate), getStartOfTheDayDate(maxDate)];
    }, [minDate, maxDate]);
    const hideCalendar = () => setCalendarIsShown(false);
    const showCalendar = () => setCalendarIsShown(true);
    const inputRef = useRef(null);
    const popperRef = useRef(null);
    const calendarRef = useRef(null);
    const inputWrapperRef = useRef(null);
    // Active (visible) month of the calendar that required for manual entering of
    // a single date
    const activeMonth = calendarValue instanceof Date ? calendarValue : undefined;
    // Format the input based on its 'focus' state
    const formatInputValue = useCallback((valueToFormat) => {
        return Array.isArray(valueToFormat)
            ? formatDateRange(valueToFormat, displayDateFormat)
            : formatDate(valueToFormat, isInputFocused ? editDateFormat : displayDateFormat);
    }, [isInputFocused, editDateFormat, displayDateFormat]);
    const updateInputValue = useCallback(({ preventUpdateOnFocus }) => {
        if (preventUpdateOnFocus && isInputFocused) {
            return;
        }
        setInputValue(() => {
            if (!value) {
                return EMPTY_INPUT_VALUE;
            }
            return formatInputValue(timezoneConvert(value, timezone));
        });
    }, [value, isInputFocused, timezone, formatInputValue]);
    // Keep the input value in sync with date value update
    // Updating on incoming date value or timezone change
    // Should not update when input is focused to prevent overriding it's value
    useEffect(() => {
        updateInputValue({ preventUpdateOnFocus: true });
    }, [value, timezone]);
    // Keep the input format in sync with its 'focus' state
    // Updating on input focus state change
    useEffect(() => {
        updateInputValue({ preventUpdateOnFocus: false });
    }, [isInputFocused]);
    // Keep the calendar in sync with the input value
    useEffect(() => {
        setCalendarValue(() => {
            if (!value) {
                return null;
            }
            return timezoneConvert(value, timezone);
        });
    }, [value, timezone]);
    const isInsideDatePicker = (node) => {
        var _a, _b;
        return (((_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.popper.contains(node)) ||
            ((_b = inputWrapperRef.current) === null || _b === void 0 ? void 0 : _b.contains(node)));
    };
    const handleBlur = (event) => {
        const isFocusedInsideDatePicker = isInsideDatePicker((event.relatedTarget || document.activeElement));
        if (isFocusedInsideDatePicker) {
            return;
        }
        hideCalendar();
        onBlur();
        setIsInputFocused(false);
    };
    const handleInputChange = (e) => {
        const nextValue = e.target.value;
        // TODO: change this if manual entering of range is needed
        if (range && nextValue) {
            return;
        }
        // TODO: add char filtering (only number , `-` or ` ` allowed) in case if `parseInputValue` is not set
        setInputValue(nextValue);
        if (!nextValue) {
            return onChange(null);
        }
        const parsedInputDate = datePickerParseDateString(nextValue, {
            customParser: parseInputValue,
            dateFormat: editDateFormat,
            timezone,
            minDate: normalizedMinDate,
            maxDate: normalizedMaxDate,
        });
        if (parsedInputDate) {
            onChange(parsedInputDate);
        }
    };
    const focus = () => {
        if (inputRef && inputRef.current) {
            inputRef.current.focus();
        }
    };
    const handleCalendarChange = (nextValue) => {
        const nextTimezoneValue = Array.isArray(nextValue)
            ? nextValue.map((date) => timezoneFormat(date, timezone))
            : timezoneFormat(nextValue, timezone);
        onChange(nextTimezoneValue);
        setInputValue(formatInputValue(nextValue));
        setCalendarValue(nextValue);
        if (hideOnSelect) {
            focus();
            hideCalendar();
        }
    };
    const handleInputKeydown = (event) => {
        var _a;
        const key = event.key;
        if (key === 'Escape') {
            hideCalendar();
            event.currentTarget.blur();
            return;
        }
        if (key === 'Enter') {
            if (!calendarIsShown) {
                showCalendar();
            }
            else {
                hideCalendar();
            }
            return;
        }
        if (key === 'Tab' && calendarIsShown) {
            event.preventDefault();
            event.stopPropagation();
            if (!calendarIsShown) {
                event.currentTarget.blur();
            }
            else {
                // TODO: Manage this whole logic inside simple-react-calendar
                const firstButton = (_a = calendarRef.current) === null || _a === void 0 ? void 0 : _a.querySelector('button:not([tabindex="-1"])');
                if (firstButton) {
                    firstButton.focus();
                }
            }
        }
    };
    const handleFocusOrClick = () => {
        if (disabled) {
            return;
        }
        showCalendar();
        setIsInputFocused(true);
    };
    const handleResetClick = (event) => {
        setInputValue(EMPTY_INPUT_VALUE);
        onResetClick === null || onResetClick === void 0 ? void 0 : onResetClick(event);
    };
    const startAdornment = size !== 'small' ? (React.createElement(InputAdornment, { position: 'start', disablePointerEvents: true }, icon || React.createElement(Calendar16, null))) : undefined;
    return (React.createElement(React.Fragment, null,
        React.createElement(Container, { inline: width !== 'full', ref: inputWrapperRef },
            React.createElement(Input, Object.assign({}, inputProps, { status: error ? 'error' : status, disabled: disabled, ref: inputRef, onKeyDown: handleInputKeydown, onClick: handleFocusOrClick, onFocus: handleFocusOrClick, onBlur: handleBlur, onResetClick: handleResetClick, value: inputValue, onChange: handleInputChange, size: size, startAdornment: startAdornment, width: width, testIds: testIds, "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.input }))),
        inputWrapperRef.current && (React.createElement(Popper, Object.assign({ placement: 'bottom-start', open: calendarIsShown, anchorEl: inputWrapperRef.current, autoWidth: false, enableCompactMode: true, container: popperContainer, popperOptions: DEFAULT_POPPER_OPTIONS, ref: popperRef }, popperProps),
            React.createElement(Calendar, { activeMonth: activeMonth, "data-testid": testIds === null || testIds === void 0 ? void 0 : testIds.calendar, ref: calendarRef, range: range, value: calendarValue !== null && calendarValue !== void 0 ? calendarValue : undefined, minDate: normalizedMinDate, maxDate: normalizedMaxDate, disabledIntervals: disabledIntervals, indicatedIntervals: indicatedIntervals, renderDay: renderDay, onChange: handleCalendarChange, onBlur: handleBlur, className: classes.calendar, hasFooter: Boolean(footer), weekStartsOn: weekStartsOn }),
            footer && (React.createElement("div", { className: classes.footer, style: { backgroundColor: footerBackgroundColor } }, footer))))));
};
DatePicker.defaultProps = {
    range: false,
    hideOnSelect: true,
    onBlur: noop,
    editDateFormat: 'MM-dd-yyyy',
    displayDateFormat: 'MMM d, yyyy',
    autoComplete: 'off',
    status: 'default',
};
DatePicker.displayName = 'DatePicker';
export default DatePicker;
//# sourceMappingURL=DatePicker.js.map