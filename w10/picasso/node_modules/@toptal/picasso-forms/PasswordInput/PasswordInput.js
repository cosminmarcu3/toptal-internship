var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useEffect, useState, useCallback } from 'react';
import { FieldRequirements } from '@toptal/picasso';
import { validators } from '../utils';
import FieldLabel from '../FieldLabel';
import passwordValidators from './validators';
import InputField from '../InputField';
import FieldRenderer from './FieldRenderer';
const { composeValidators } = validators;
const ANIMATION_TIMEOUT = 500; // same as in Picasso/FieldRequirements
const validatePassword = (value) => {
    if (!value) {
        return undefined;
    }
    const isValidPassword = passwordValidators.atLeastEightCharacters(value) &&
        passwordValidators.atLeastOneNumber(value) &&
        passwordValidators.atLeastOneUpperCaseCharacter(value) &&
        passwordValidators.atLeastOneLowerCaseCharacter(value) &&
        passwordValidators.atLeastOneSpecialCharacter(value);
    return isValidPassword ? undefined : 'Please enter a valid password.';
};
export const PasswordInput = (_a) => {
    var { validate, hideRequirements } = _a, rest = __rest(_a, ["validate", "hideRequirements"]);
    const [focused, setFocused] = useState(false);
    const [showRequirements, setShowRequirements] = useState(false);
    useEffect(() => {
        if (!focused) {
            // Hide the requirements after a short delay
            const timeout = setTimeout(() => {
                setShowRequirements(false);
            }, ANIMATION_TIMEOUT);
            return () => {
                clearTimeout(timeout);
            };
        }
        setShowRequirements(true);
    }, [focused]);
    const validationsObject = hideRequirements
        ? validate
        : composeValidators([validatePassword, validate]);
    const renderFieldRequirements = ({ value, error }) => (React.createElement(FieldRequirements, { value: value, open: showRequirements, error: error, description: 'Please make sure that your password contains:', timeout: ANIMATION_TIMEOUT, requirements: [
            {
                message: 'At least 8 characters',
                validator: passwordValidators.atLeastEightCharacters,
            },
            {
                message: '1 number',
                validator: passwordValidators.atLeastOneNumber,
            },
            {
                message: '1 uppercase character',
                validator: passwordValidators.atLeastOneUpperCaseCharacter,
            },
            {
                message: '1 special character',
                validator: passwordValidators.atLeastOneSpecialCharacter,
            },
            {
                message: '1 lowercase character',
                validator: passwordValidators.atLeastOneLowerCaseCharacter,
            },
        ] }));
    const handleShowContent = useCallback(() => {
        setFocused(true);
    }, []);
    const handleHideContent = useCallback(() => {
        setFocused(false);
    }, []);
    return (React.createElement(InputField, Object.assign({}, rest, { validate: validationsObject, renderFieldRequirements: !hideRequirements ? renderFieldRequirements : undefined, label: rest.label ? (React.createElement(FieldLabel, { name: rest.name, required: rest.required, label: rest.label, titleCase: rest.titleCase })) : null }), (inputProps) => {
        return (React.createElement(FieldRenderer, Object.assign({}, inputProps, { onHideContent: handleHideContent, onShowContent: handleShowContent })));
    }));
};
PasswordInput.displayName = 'PasswordInput';
export default PasswordInput;
//# sourceMappingURL=PasswordInput.js.map